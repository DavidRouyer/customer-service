enum TicketStatus {
  OPEN
  DONE
}

enum TicketStatusDetail {
  CREATED
  NEW_REPLY
  REPLIED
}

enum TicketPriority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

type Ticket implements Node {
  id: ID!
  title: String
  status: TicketStatus!
  statusDetail: TicketStatusDetail
  statusChangedAt: DateTime
  statusChangedBy: User
  labels: [Label!]!
  priority: TicketPriority!
  timelineEntries(
    first: Int
    after: String
    last: Int
    before: String
  ): TimelineEntryConnection!
  assignedTo: User
  customer: Customer!
  createdAt: DateTime!
  createdBy: User!
  updatedAt: DateTime
  updatedBy: User
}

type TicketEdge {
  cursor: String!
  node: Ticket!
}

type TicketConnection {
  edges: [TicketEdge!]!
  pageInfo: PageInfo!
}

type AssignmentChangedEntry {
  oldAssignedTo: User
  newAssignedTo: User
}

type ChatEntry {
  text: String!
}

type LabelsChangedEntry {
  oldLabels: [Label!]!
  newLabels: [Label!]!
}

type NoteEntry {
  text: String!
  rawContent: String!
}

type PriorityChangedEntry {
  oldPriority: TicketPriority
  newPriority: TicketPriority
}

type StatusChangedEntry {
  oldStatus: TicketStatus
  newStatus: TicketStatus
}

union Entry =
  | AssignmentChangedEntry
  | ChatEntry
  | LabelsChangedEntry
  | NoteEntry
  | PriorityChangedEntry
  | StatusChangedEntry

type TicketEdge {
  cursor: String!
  node: Ticket!
}

type TimelineEntry implements Node {
  id: ID!
  customer: Customer!
  entry: Entry!
  ticketId: ID!
  createdAt: DateTime!
  customerCreatedBy: Customer
  userCreatedBy: User
}

type TimelineEntryConnection {
  edges: [TimelineEntryEdge!]!
  pageInfo: PageInfo!
}

type TimelineEntryEdge {
  cursor: String!
  node: TimelineEntry!
}

input TicketsFilter {
  statuses: [TicketStatus!]
  customerIds: [ID!]
  isAssigned: Boolean
}

type Query {
  ticket(id: ID!): Ticket
  tickets(
    filters: TicketsFilter
    first: Int
    after: String
    last: Int
    before: String
  ): TicketConnection!
}
